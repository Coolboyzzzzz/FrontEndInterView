# 1.自我介绍

我叫，今年21岁，就读于____河北师范大学计算机科学与技术专业，拥有扎实的js,css html基础 ，良好的编程风格;熟悉前后端分离模式的web开发;熟悉vue等框架等开源框架; 熟悉nodejs等，熟悉基于linu及uni环境下的软件开发;

在校期间有多次项目经历，参与过电商平台的开发。参加过学校组织的程序设计大赛，以及参与蓝桥杯Web应用开发，并获省级二等奖。虽然实际工作经验不是很足，但在学校中培养了我扎实的学科基础知识和较强的专业技能，

我想在走上工作岗 位之后，我可以以最快的速度适应工作环境，不断挖掘自己的能力，完善自己，为企业 创造效益。我想加入公司是因为我喜欢我的专业，也很看好公司的未来发展，在这里我可以学以致用，这让我有很大的成就感和幸福感。同时我也很欣赏 公司的企业文化，很喜欢公司的工作环境。我愿意成为企业一员，为企业的发展贡献自己的一份力量。 我的职业生涯目标是，做一个既懂技术，又懂业务的复合型人才。

#  2.输入 URL 到页面加载显示完成发生了什么?

DNS 解析 TCP 连接 发送HTTP 请求 服务器处理请求并返回 HTTP 报 文浏览器解析渲染页面 连接结束

输入url 后，首先需要找到这个 url 域名的服务器ip,为了寻找这个ip，浏览器首先会寻 找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器 缓存，缓存中没有则查找系统的 hosts 文件中是否有记录，如果没有则查询 DNS 服务器， 得到服务器的ip 地址后，浏览器根据这个ip 以及相应的端口号，构造一个 http 请求， 这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据， 并将这个http 请求封装在一个tcp 包中，这个tcp 包会依次经过传输层，网络层， 数据 链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的html 给浏 览器，因为 html 是一个树形结构，浏览器根据这个 html 来构建 DOM 树，在dom 树的 构建过程中如果遇到JS 脚本和外部JS 连接，则会停止构建 DOM 树来执行和下载相应 的代码，这会造成阻塞，这就是为什么推荐 JS 代码应该放在html 代码的后面，之后根 据外部央视，内部央视，内联样式构建一个 CSS 对象模型树CSSOM 树，构建完成后和 DOM 树合并为渲染树，这里主要做的是排除非视觉节点，比如 script，meta 标签和排除 display 为none 的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html 文件中会含有图片，视频，音频等资源，在解析 DOM 的过 程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制,一般 是 4-6 个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache- Control、Last-Modify、Expires 等首部字段控制。 Cache-Control 和 Expires 的区别在 于Cache-Control 使用相对时间，Expires 使用的是基于服务器 端的绝对时间，因为存在 时差问题，一般采用 Cache-Control，在请求这些有设置了缓存的数据时，会先 查看是 否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改， 如果上一次 响应设置了ETag 值会在这次请求的时候作为 If-None-Match 的值交给服务 器校验，如果一致，继续校验 Last-Modified，没有设置ETag 则直接验证 Last-Modified，再决定是否返回 304。

# 3.CSS到底会不会阻塞页面渲染

- css加载不会阻塞DOM树的解析

- css加载会阻塞DOM树的渲染

- css加载会阻塞后面js语句的执行

  - HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree
  - 将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)
  - 根据Render Tree渲染绘制，将像素渲染到屏幕上。

  从流程我们可以看出来

  - DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。

  - 然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。

  - 由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。

  - ## **DOMContentLoaded**

    对于浏览器来说，页面加载主要有两个事件，一个是DOMContentLoaded，另一个是onLoad。而onLoad没什么好说的，就是等待页面的所有资源都加载完成才会触发，这些资源包括css、js、图片视频等。

    而DOMContentLoaded，顾名思义，就是当页面的内容解析完成后，则触发该事件。那么，正如我们上面讨论过的，css会阻塞Dom渲染和js执行，而js会阻塞Dom解析。那么我们可以做出这样的假设

    - 当页面只存在css，或者js都在css前面，那么DomContentLoaded不需要等到css加载完毕。
    - 当页面里同时存在css和js，并且js在css后面的时候，DomContentLoaded必须等到css和js都加载完毕才触发。

# 4.https为什么比http安全

## 1.SSL/TLS协议的基本思路

是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

- （1）客户端向服务器端发起SSL连接请求；
- （2） 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥
- （3）客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端
- （4）服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，
- （5）进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。

## 2.为什么https安全

https协议：是由SSL＋HTTP协议构建的可进行加密传输、身份认证的网络协议。`HTTPS`与`HTTP`虽然只差一个TSL/`SSL`，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下：

## 2.1机密性：混合算法

混合加密
在HTTPS通信过程中，采用的是对称加密+非对称加密，也就是混合加密   在对称加密中讲到，如果能够保证了密钥的安全，那整个通信过程就可以说具有了机密性而HTTPS采用非对称加密解决秘钥交换的问题    具体做法是发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”

## 2.2完整性：摘要算法

可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”

## 2.3身份认证 + 不可否定：数字签名

数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名

原理其实很简单，就是用私钥加密，公钥解密

签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥

这时候就需要一个第三方，就是证书验证机构

摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场

## 3.如何保证公钥不被篡改？

将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

公钥加密计算量太大，如何减少耗用的时间？

每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。

由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。

- （1） 客户端向服务器端索要并验证公钥。
- （2） 双方协商生成”对话密钥”。
- （3） 双方采用”对话密钥”进行加密通信。上面过程的前两步，又称为”握手阶段”（handshake）。

#  5.事件代理 

利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始， 然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div>ul>li>a;比如给最里 面的a 加一个 click 点击事件，那么这个事件就会一层一层的往外执行，执行顺序 a>li>ul>div，有这样一个机制，那么我们给最外面的 div 加点击事件，那么里面的 ul，li， a 做点击事件的时候，都会冒泡到最外层的 div 上，所以都会触发，这就是事件代理， 代 理它们父级代为执行事件

# 6.HTTP协议

## 6.1常见的 HTTP 的头部

可以将http 首部分为通用首部，请求首部，响应首部，实体首部 通用首部表示一些通用信息，比如 date 表示报文创建时间， 请求首部就是请求报文中独有的，如 cookie，和缓存相关的如 if-Modified-Since 响应首部就是响应报文中独有的，如 set-cookie，和重定向相关的location， 实体首部用来描述实体部分，如allow 用来描述可执行的请求方法，content-type 描述 主题类型，content-Encoding 描述主体的编码方式。

## 6.2cache-control 的值有哪些 

 cache-control 是一个通用消息头字段被用于HTTP 请求和响应中，通过指定指令来实现 缓存机制，这个缓存指令是单向的，常见的取值有 private、no-cache、max-age、 must-revalidate 等，默认为private

##  6.3HTTP2.0 的特性 

6.3.1多路复用

  HTTP2.0使用了多路复用的技术，做到同一个连接[并发](https://so.csdn.net/so/search?q=并发&spm=1001.2101.3001.7020)处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。

6.3.2 头部数据压缩
       在HTTP1.1中，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。

6.3.3 服务器推送
       服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。

6.3.4二进制分帧：HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二 进制编码

       为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。
## 6.4HTTP1.0和HTTP1.1

1 HTTP1.0和HTTP1.1的区别
1.1 长连接(Persistent Connection)
       HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。

1.2 节约带宽
       HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。

1.3 HOST域
       在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。

1.4缓存处理
       在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

1.5错误通知的管理
       在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

## 6.5为什么是三次握手

首先，tcp是可靠传输协议，需要三次握手建立连接服务。

三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：client端发出了一个连接请求报文，而是因为某些未知的原因在某个网络节点上发生延迟、滞留，导致延迟到连接释放以后的某个时间才到达server端。本来这是一个早已失效的报文段，但是server收到此失效的报文之后，会误认为是client再次发出的一个新的连接请求，于是server端就向client又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要server端发出确认报文就会认为新的连接已经建立了，但是client端此时并没有发出建立连接的请求，因此不会去向server端发送数据，server端没有收到数据就会一直等待，产生死锁现象，这样server端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，client端首先发出连接请求并进入等待状态，server接收连接请求后同意建立连接，并向client返回报文段表示已经建立连接server进入SYN_RECV状态，client接收到server发出的确认信息后自己再发出确认信息，然后就可以建立直接通信。所以说只有三次握手在逻辑上才是最合适的，可以保障可靠性。

## 6.6为什么是四次挥手

   根据三次握手，那么为什么不能是三次挥手呢？中间的两个部分为什么不能一起发送呢？   这个因为第一次挥手表示客户端发送了一个fin的包，表示客户端已发送数据完毕，但是服务端这个时候可能还有数据没有发送完成，先发送给客户端一个ask的包，等待自己的数据发送完成才能向客户端发送一个 fin的包，表示自己的数据也已发送完成。这样中间就必须为两次来发送ask和fin。





## 6.7（ISN）是固定的吗？

​      三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。

      如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

**ISN代表什么？意义何在？**

ISN，发送方的字节数据编号的原点，让对方生成一个合法的接收窗口。



## 6.8tcp半连接队列

服务端收到客户端发起的 SYN 请求后，**内核会把该连接存储到半连接队列**，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，**内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来**





**刚才你提到第三方可以伪造RST报文，需要满足什么条件才能得逞？**

需要sequence number 位于对方的合法接收窗口内。 而由于ISN是动态随机的，猜出对方合法接收窗口难度加大。

如果ISN = 0，那么猜出的难度就大大降低。





**对方难道不可以将数据缓存下来，等握手成功再提交给应用程序？**

这样会放大SYN FLOOD攻击。

如果攻击者伪造了成千上万的握手报文，携带了1K+ 字节的数据，而接收方会开辟大量的缓存来容纳这些巨大数据，内存会很容易耗尽，从而拒绝服务。



3、三次握手过程中可以携带数据吗
      很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。

为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。
而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。

**看到有人说，只看到过TCP状态位为** **’FIN +ACK’，但从来没有看过状态位只有** **‘FIN’，你应该怎样给他解释？**

RFC793明确规定，除了第一个握手报文SYN除外，其它所有报文必须将ACK = 1。



**很好，RFC规定的背后肯定有合理性的一面，能否深究一下原因？**

TCP作为一个可靠传输协议，其可靠性就是依赖于收到对方的数据，ACK对方，这样对方就可以释放缓存的数据，因为对方确信数据已经被接收到了。

但TCP报文是在IP网络上传输，丢包是家常便饭，接收方**要抓住一切的机会，把消息告诉发送方**。最方便的方式就是，任何我方发送的TCP报文，都要捎带着ACK状态位。



**ACK状态位单独能承担这个消息传递的任务吗？**

不能！需要有 Acknowledge Number配合才行。

如果我方发出的Acknowledge Number == 10001，那意味着[序列号](https://www.zhihu.com/search?q=序列号&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A398114686})10000及之前的字节已经成功接收。

如果对方占据字节序列号10000是[应用层](https://www.zhihu.com/search?q=应用层&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A398114686})数据，那么就是确认应用层数据。

如果对方占据字节序列号10000是’FIN’状态位，那么就是确认接收到对方的’FIN’















来讲讲 JS 的闭包吧 参考回答： 闭包是指有权访问另外一个函数作用域中的变量的函数。 闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是 就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分 配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。 （2） 为什么要用： 匿名自执行函数：我们知道所有的变量，如果不加上var 关键字，则默认的会添加到全 局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用 这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍 历的)。除了每次使用变量都是用 var 关键字外，我们在实际情况下经常遇到这样一种情 况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象， 每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数 的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找 到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用， 从而函数内部的值可以得以保留。

# 7.csrf 和 xss 的网络攻击及防范

CSRF：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶 意请求，比如用户登录了一个网站后，立刻在另一个ｔａｂ页面访问量攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF 就 产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据 库的，这时候攻击者就可以以用户的名义操作这个数据库，防御方式的话：使用验证码， 检查https 头部的refer，使用token 

XSS：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻 击，比如获取cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻 击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的 话不存储在数据库中，往往表现为将攻击代码放在 url 地址的请求参数中，防御的话为 cookie 设置httpOnly 属性，对用户的输入进行检查，进行特殊字符过滤。

# 8.cookie 有哪些字段可以设置

name 字段为一个cookie 的名称。 value 字段为一个cookie 的值。 domain 字段为可以访问此cookie 的域名。 非顶级域名，如二级域名或者三级域名，设置的 cookie 的domain 只能为顶级域名或者 二级域名或者三级域名本身，不能设置其他二级域名的 cookie，否则cookie 无法生成。 顶级域名只能设置domain 为顶级域名，不能设置为二级域名或者三级域名，否则 cookie 无法生成。 二级域名能读取设置了 domain 为顶级域名或者自身的 cookie，不能读取其他二级域 名domain 的cookie。所以要想cookie 在多个二级域名中共享，需要设置 domain 为顶 级域名，这样就可以在所有二级域名里面或者到这个 cookie 的值了。 顶级域名只能获取到domain 设置为顶级域名的cookie，其他domain 设置为二级域名的 无法获取。 path 字段为可以访问此cookie 的页面路径。 比如domain 是abc.com,path 是/test，那么 只有/test 路径下的页面可以读取此cookie。 expires/Max-Age 字段为此cookie 超时时间。若设置其值为一个时间，那么当到达此时间 后，此 cookie 失效。不设置的话默认值是 Session，意思是 cookie 会和session 一起失效。 当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此 cookie 失效。 Size 字段 此cookie 大小。 http字段 cookie的httponly属性。若此属性为true，则只有在http 请求头中会带有此 cookie的信息，而不能通过document.cookie 来访问此cookie。 secure 字段 设置是否只能通过https 来传递此条cookie



# 9.event loop

1、微任务（MircoTask）

Promise中的then、catch、finally
Process.nextTick（Node环境，通常也被认为是微任务）

MutationObserver监视 DOM 变动的API

2、宏任务（MacroTask/Task）
基本上，我们将javascript中非微任务（MircoTask）的所有任务都归为宏任务，比如：script中全部代码 DOM操作 用户交互操作
所有的网路请求  定时器相关的 setTimeout、setInterval 等

值得一提的是，整个<script>标签包裹的整体代码，是属于宏任务。

任务会依次进入执行栈，而首先入场的就是——宏任务全局上下文(script)；
执行同步任务；
js 引擎遇到一个异步任务后并不会一直等待其返回结果：
遇到异步任务，交给异步处理模块处理，对应的异步处理线程处理异步任务需要的操作，例如定时器的计数和异步请求监听状态的变更；
当异步事件返回结果后，事件触发线程将回调函数（标记）加入任务队列，等待栈为空时，依次进入栈中执行；
执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空：
先检查微任务(microTask)队列，如果存在任务，则一次性执行完所有微任务，无任务则跳过
后检查宏任务(macroTask)队列，如果存在任务，则取出第一个宏任务，执行，
总结 1:

每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为 null，然后再执行宏任务，如此循环。

总结 2:

又因为第一次进入执行栈的总是宏任务（Script），而每次宏任务完成后，都会读取微任务队列，所以，大家也会听见另一种表述方式：、

每一轮循环中，同步任务执行后会在末尾执行并清空所有的微任务，会在下一轮循环中取第一个宏任务执行，如此循环。

宏任务和微任务是相对而言的，根据代码执时循环的先后，将代码执行分层理解，在每一层（一次）的事件循环中，首先整体代码块看作一个宏任务，宏任务中的 Promise（then、catch、finally）、、Process.nextTick就是该宏任务层的微任务；宏任务中的同步代码进入主线程中立即执行的，宏任务中的非微任务异步执行代码将作为下一次循环的宏任务时进入调用栈等待执行的；此时，调用栈中等待执行的队列分为两种，优先级较高先执行的本层循环微任务队列（MicroTask Queue），和优先级低的下层循环执行的宏任务队列（MacroTask Queue）！
注意：每一次/层循环，都是首先从宏任务开始，微任务结束;

# 10.WebSocket 的实现和应用

(1) 什么是WebSocket?

WebSocket 是HTML5 中的协议，支持持久连续，http 协议不支持持久性连接。Http1.0 和 HTTP1.1 都不支持持久性的链接，HTTP1.1 中的keep-alive，将多个http 请求合并 为1 个 (2) WebSocket 是什么样的协议，具体有什么优点？ HTTP 的生命周期通过 Request 来界定，也就是Request 一个Response，那么在 Http1.0 协议中，这次Http 请求就结束了。在 Http1.1 中进行了改进，是的有一个 connection： Keep-alive，也就是说，在一个 Http 连接中，可以发送多个 Request，接收 多个 Response。但是必须记住，在Http 中一个Request 只能对应有一个Response，而 且这个Response 是被动的，不能主动发起。 WebSocket 是基于Http 协议的，或者说借用了 Http 协议来完成一部分握手，在握手阶段 与 Http 是相同的。我们来看一个 websocket 握手协议的实现，基本是 2 个属性，upgrade， connection。

# 11.线程与进程的区别

```
一个程序至少有一个进程,一个进程至少有一个线程. 
线程的划分尺度小于进程，使得多线程程序的并发性高。 
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
```

# 12.性能优化

性能优化 参考回答： 减少HTTP 请求 使用内容发布网络（CDN） 添加本地缓存 压缩资源文件 将 CSS 样式表放在顶部，把javascript 放在底部（浏览器的运行机制决定） 避免使用CSS 表达式 减少DNS 查询 使用外部javascript 和CSS 避免重定向 图片lazyLoad

# 13.重绘重排

重绘（repaint 或 redraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等 都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。 重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制， 使元素呈现新的外观。 触发重绘的条件：改变元素外观属性。如：color，background-color 等。 注意：table 及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比 同等元素要多花两倍时间，这就是我们尽量避免使用table 布局页面的原因之一。 

重排（重构/回流/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局， 隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是 在页面第一次加载的时候。 重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构 造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为 重绘。所以，重排必定会引发重绘，但重绘不一定会引发重排。

## 12.1怎么去减少重绘和重排吗

让文档脱离文档流有 哪些方法 参考回答： DOM 的变化影响到了预算内宿的几何属性比如宽高，浏览器重新计算元素的几何属性， 其他元素的几何属性也会受到影响，浏览器需要重新构造渲染书，这个过程称之为重排，浏 览器将受到影响的部分重新绘制在屏幕上 的过程称为重绘，引起重排重绘的原因有： 

1.添加或者删除可见的DOM 元素， 

元素尺寸位置的改变 浏览器页面初始化，

 浏览器窗口大小发生改变，重排一定导致重绘，重绘不一定导致重排， 减少重绘重排的方法有： 不在布局信息改变时做 DOM 查询， 使用csstext,className 一次性改变属 性使用fragment 对于多次重排的元素，比如说动画。使用绝对定位脱离文档流，使其不影响其他元素 DOM离线化

## DOM离线化

1.使用display控制显隐，临时将要操作的元素从文档流中脱离，然后再恢复它2.使用 createDocumentFragment，创建文档片段，操作后一次性把文档片段添加到文档流中（缓存批量化dom操作）3.创建节点副本，在副本上进行操作，最后进行替换。

## DocumentFragment

## requestAnimationFrame() 方法

告诉浏览器您希望执行动画并请求浏览器在下一次重绘之 前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在 浏览器重绘之前调用。

# 14.getBoundingClientRect

getBoundingClientRect()获取元素位置，这个方法没有参数

getBoundingClientRect()用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置。 

getBoundingClientRect()是DOM元素到浏览器可视范围的距离（不包含文档卷起的部分）

该函数返回一个Object对象，该对象有6个属性：top,lef,right,bottom,width,height； 

rectObject.top：元素上边到视窗上边的距离;
	rectObject.right：元素右边到视窗左边的距离;
	rectObject.bottom：元素下边到视窗上边的距离;
	rectObject.left：元素左边到视窗左边的距离;
	rectObject.width：是元素自身的宽
	rectObject.height是元素自身的高

# 15.computed与watch的区别

1、功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。
2、是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。
3、是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。
4、computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）deep 深度监听 handler；回调
5、使用场景：computed----当一个属性受多个属性影响的时候，使用computed-----购物车商品结算。watch–当一条数据影响多条数据的时候，使用watch-----搜索框

# 16.vue核心面试题：diff算法

一、diff算法的时间复杂度 
两个树的完全的 diff 算法是一个时间复杂度为 O(n3) , Vue 进行了优化·O(n3) 复杂度的问题转换成 O(n) 复杂度的问题(只比较同级不考虑跨级问题)，因为在前端操作dom的时候了，不会把当前元素作为上一级元素或下一级元素，很少会跨越层级地移动Dom元素，常见的都是同级的比较。 所 以 Virtual Dom只会对同一个层级的元素进行对比。 

二、vue中diff算法的原理
在数据发生变化，vue是先根据真实DOM生成一颗 virtual DOM ，当 virtual DOM 某个节点的数据改变后会生成一个新的 Vnode ，然后 Vnode 和 oldVnode 作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使 oldVnode 的值为 Vnode ，来实现更新节点。

1.原理简述：
（1）先去同级比较，然后再去比较子节点

（2）先去判断一方有子节点一方没有子节点的情况

（3）比较都有子节点的情况

（4）递归比较子节点

  在进行节点比较时，是通过patch这个方法实现，其中如果不是真实元素并且用sameVnode看两个是否是同一个元素，如果是然后会调用patchVnode进行比较，比较的是虚拟节点不是真实节点，如果不值得去比较则用 Vnode 替换 oldVnode。patchVnode会比较这两个节点，判断 Vnode 和 oldVnode 是否指向同一个对象，如果是，那么直接 return，复用老的真是元素。如果不是会用新的子节点和旧的字节做比较。如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点；如果两个都有子节点的情况下会调用updateChildren方法比较他们的子节点；只有新的节点有子节点而旧节点没有子节点，就会把新增的子节点插入到旧的dom中；如果当前新的节点中没有子节点，旧的中有子节点，然后就会把旧的节点删除掉；

updateChildren方法中，先定义了四对指针，先比较新的和旧的第一个子节点是否一样，如果一样会移动前面两个指针，以此类推，如果比对最后新的节点多了一个子节点就把它插入旧的中。如果开始第一个子节点不一样就从后面开始进行比较（从尾子节点开始比较），比到最后把新增的节点插入到旧的dom中。还有这种情况就是头和尾节点都不相等的情况下，用当前的头和旧的尾节点进行比较，如果一样就把旧的尾节点移到前面去，然后将旧的尾指针向前移动一位，当前头指针移动到下一个子节点上。另一种就是用旧的结尾和新的开头节点进行比较，四种比较策略。如果存在key，就会拿的当前子节点的key去旧的子节点中找，如果找到就将它移动到旧节点的前面，然后就将指针移向当前节点的第二个子节点上，以此类推，如果当前子节点没有就将它直接插入到旧的节点中，最后把旧的节点中多余出的子节点删除掉。


# 17.JS 的垃圾回收机制

 参考回答： GC（garbage collection），GC 执行时，中断代码，停止其他操作，遍历所有对象，对 于不可访问的对象进行回收，在 V8 引擎中使用两种优化方法， 分代回收，2、增量GC，目的是通过对象的使用频率，存在时长来区分新生代和老生 代对象，多回收新生代区，少回收老生代区，减少每次遍历的时间，从而减少GC 的耗 时回收方法： 引用计次，当对象被引用的次数为零时进行回收，但是循环引用时，两个对象都至少被引 用了一次，因此导致内存泄漏， 标记清除