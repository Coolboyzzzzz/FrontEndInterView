1、微任务（MircoTask）
  在 HTML 标准中，并没有明确规定 Microtask，但是实际开发中包含以下四种：

Promise中的then、catch、finally（原理参考：【js进阶】手撕Promise，一码一解析 包懂）
MutationObserver（监视 DOM 变动的API，详情参考MDN）
Object.observe(废弃：监听标准对象的变化)
Process.nextTick（Node环境，通常也被认为是微任务）
2、宏任务（MacroTask/Task）
  基本上，我们将javascript中非微任务（MircoTask）的所有任务都归为宏任务，比如：

script中全部代码
DOM操作
用户交互操作
所有的网路请求
定时器相关的 setTimeout、setInterval 等



值得一提的是，整个<script>标签包裹的整体代码，是属于宏任务。

任务会依次进入执行栈，而首先入场的就是——宏任务全局上下文(script)；
执行同步任务；
js 引擎遇到一个异步任务后并不会一直等待其返回结果：
遇到异步任务，交给异步处理模块处理，对应的异步处理线程处理异步任务需要的操作，例如定时器的计数和异步请求监听状态的变更；
当异步事件返回结果后，事件触发线程将回调函数（标记）加入任务队列，等待栈为空时，依次进入栈中执行；
执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空：
先检查微任务(microTask)队列，如果存在任务，则一次性执行完所有微任务，无任务则跳过
后检查宏任务(macroTask)队列，如果存在任务，则取出第一个宏任务，执行，
总结 1:

每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为 null，然后再执行宏任务，如此循环。

总结 2:

又因为第一次进入执行栈的总是宏任务（Script），而每次宏任务完成后，都会读取微任务队列，所以，大家也会听见另一种表述方式：、

每一轮循环中，同步任务执行后会在末尾执行并清空所有的微任务，会在下一轮循环中取第一个宏任务执行，如此循环。

  看到这里，可能会有很多疑惑：同步异步很好理解，宏任务微任务上面也进行了分类，但是当他们四个在一起后就感觉很混乱了，冥冥之中觉得同步异步和宏任务微任务有内在联系，但是他们之间有联系吗？又是什么联系呢？网上有的文章说宏任务就是同步的，微任务就是异步的 这种说法明显是错的！
  其实我更愿意如此描述：宏任务和微任务是相对而言的，根据代码执时循环的先后，将代码执行分层理解，在每一层（一次）的事件循环中，首先整体代码块看作一个宏任务，宏任务中的 Promise（then、catch、finally）、MutationObserver、Process.nextTick就是该宏任务层的微任务；宏任务中的同步代码进入主线程中立即执行的，宏任务中的非微任务异步执行代码将作为下一次循环的宏任务时进入调用栈等待执行的；此时，调用栈中等待执行的队列分为两种，优先级较高先执行的本层循环微任务队列（MicroTask Queue），和优先级低的下层循环执行的宏任务队列（MacroTask Queue）！
注意：每一次/层循环，都是首先从宏任务开始，微任务结束;

