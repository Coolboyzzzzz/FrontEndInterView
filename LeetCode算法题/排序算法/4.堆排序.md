# 堆排序

堆的特性：

- 必须是完全二叉树；
- 任一结点的值是其子树所有结点的最大值或最小值。 最大值时，称为“**最大堆**”，也称大顶堆； 最小值时，称为“**最小堆**”，也称小顶堆。

堆排序主要用到最大堆/最小堆的删除操作，也即根节点已经是最大/小的值，排序的话，只需要把根结点拿（删）掉，放入有序的新数组里，然后用下沉算法处理剩余的结点以便组成新的最大堆/最小堆……如此循环。

所谓下沉算法，拿最小堆来举例说（最大堆同理），就是把完全二叉树根结点R和该树第二层左右子结点的值比较，如果大，结点就互换位置（“下沉”），以此逐层递归，直到处理完整棵树，此时，根节点值最小。

堆排序的时间复杂度是 $$O(NlogN)$$ 。

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<!-- 堆排序就是先把无序的数组构建一个堆的数据结构，构建一个最小堆，先从最后一个子节点开始下沉
利用一个下沉的算法这个算法的功能就是使这个堆成为最小堆，是他变成完全二叉树
完全二叉树概念：每个节点只能有两个子节点，如果一个节点只有右节点没有左节点那也不是完全二叉树
堆排列思路 首先第一次把无序数组重构为一个最小堆，那么堆顶元素就是一个最小值，新建一个数组把这个堆顶元素追到进去，即确定好一个位置
然后让第一个堆顶元素和最后一个右边叶子节点交换位置，那么我们思考，交换了位置一顶不满足最小堆，所以在进行调用重建堆函数，函数调用完毕会发现除了已经追加进
排列的元素，第二小的元素又找了出来，然后在进行把堆顶元素进行追加进去。然后数组有多少个数据就执行几次，就会排列完毕
需要注意的是 堆的特性
（数组长度-2）/2取整就是每个节点的位置，这也是堆的一个特性
其中2*节点位置+1是改节点的左节点
2*节点位置+2是改节点的右节点
构建堆的时候是从下往上进行递归构建
重排堆的时候是从上往下进行递归重排
-->

<body>
    <script>
        function Heapsort(arr) {
            build() //首先一进来就把无序的数组构建成最小堆
            var result = [] //创建一个新数组用来存储确定好的数据
            for (var i = 0; i < arr.length; i++) {
                result.push(arr[0]) //每次取栈顶元素，即最小或最大的元素，放入数组
                swap(0, arr.length - result.length) //让栈顶元素和最后一个元素交换位置
                sink(0, arr.length - result.length) //重排堆，每次排列都虎烈已经确定好元素的堆顶元素
            }
            console.log(arr)

            function build() { //构建堆函数
                for (var i = Math.floor((arr.length - 2) / 2); i >= 0; i--) {
                    //   for (var i = 0, c = Math.floor((arr.length - 2) / 2); i <= c; i++) {
                    //思考问题问什么这里建堆的时候为什么不能从根节点开始遍历
                    //经过自己测试发现如果从根节点开始就不能正确的构建堆，因为那样的话有可能叶子节点的最小值不会被发现层数较多时，首先第一次就是
                    //让根节点进行重排，发现如果根节点比左右子节点都大的时候就直接确定了堆顶的位置也不会进行递归调用，然后如果叶子节点有比堆顶还小的值
                    //就无法发现，从而形成错误的最小堆
                    console.log("正在处理的下沉结点索引为:" + i);
                    sink(i, arr.length) //从下往上进行重排，就行形成正确的最小/大堆
                }
            }

            function swap(i, j) { //交换位置
                var temp = arr[i]
                arr[i] = arr[j]
                arr[j] = temp
            }

            function sink(current, length) { //重排函数
                var min = current //把当前的位置设为默认的最小值
                var left = current * 2 + 1 //确定节点的左边元素的下标
                var right = current * 2 + 2 // 确定节点的右边元素的下标
                console.log(left, right)
                if (left < length && arr[left] < arr[min]) //如果下标的位置小于传入的堆元素的长度，并且该位置的值小于节点的最小值
                    min = left //那么把左边元素的下标设为最小值
                if (right < length && arr[right] < arr[min]) //如果上面成立的话这次其实是让左边元素和右边元素比大小，那么这样其实是三个元素比大小这样一比从而确定出这三个元素中最小的一个
                    min = right //如果成立，把右边元素的下标设为最小值
                if (min != current) { //判断最小值的下标是否发生了变化，即上面的两个if语句时候有成立的，意思就是这个默认的并不是最小的值
                    //，还有就是如果两个值没有变化就说明本次的重构已经完成，不仅进行其他的处理。或者也能说明这个元素就已经是叶子节点了不用再进行递归了,如果是叶子节点上面的条件进行进入，自然min=current，就直接跳出递归
                    swap(min, current) //让最小的值和节点交换位置，从而确保节点位置都是比叶子节点大或者小
                    sink(min, length) //在递归进行检查下面时候还有比自己大或者小的
                }
            }
            return console.log(result)
        }
        Heapsort([3, 5, 7, 2, 6, 8, 1])
    </script>
</body>

</html>
```

