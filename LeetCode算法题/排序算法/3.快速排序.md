# 快速排序

快速排序其实是[分治法]，将待排序数组里的项和基准数对比，比基准数大的放在一边，小的放另一边，然后再对左右两边的子数组重复使用这个思路，直到整个数组排序完毕。

时间复杂度最好的情况是 $$O(NlogN)$$，最差的情况是 $$O(N^2)$$。算法分析：

- 当分区选取的基准元素为待排序元素中的最大或最小值时，为最差的情况，时间复杂度和直接插入排序的一样，移动次数达到最大值

  `Cmax = 1+2+...+(n-1) = n*(n-1)/2 = O(n2)`
  此时时间复杂为 $$O(N^2)$$ ；

- 当分区选取的基准元素为待排序元素中的"中值"，为最好的情况，时间复杂度为 $$O(NlogN)$$ 。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<!-- 所谓的快速排序也是每次循环都会确定的是arr[left]的位置，因为每次把他当作基准值，一开始与最右边的比(从后往前)找出与自己小的，比自己大的就跳过
由这步我们思考下为什么这样做，这样做能得到什么结果的？
其实思考下知道，排序肯定是小的放前面，他这样比，比出一个比自己小的，肯定就不符合排序了，所以终止循环，并标记位置，等待下一步处理
第二步，开始从头开始与基准值比(从前往后)找出一个比自己大的，那这样我们去思考为什么呢？按照排序的规则不就是大的在后面吗，如果比这个基准值小那么就改待在基准值的前面
第一波寻找完毕，然后检查指针是否右边比左边大，如果大说明基准值并没有与其他的数比较完毕，则要继续循环让基准值和所有的数据比较完毕，就会得出这个基准值该呆的位置，即确定了一个位置
如果没有比较完毕就要对比基准值大与基准值小的数据进行处理，因为一定要保证基准值的正确位置，所以对这个分别与基准值大与基准值小的数据就要交换位置。
这样一交换位置，就会发生什么呢？思考下就知道了，最终左右指针确定的位置，确保左边的都是比基准值小，右边的比基准值大。从而确定基准值该呆的位置
下次进行递归
因为确定好一个位置，那么这个位置就不用再动了
所以我们就要分开两段进行递归
除了基准值本身左边分一段，右边分一段
分别用指针操作这个数组
-->
<body>
    <script>
        var arr = [6, 8, 3, 2, 3, 6]
        function quick(left, right) { //分别接收左右指针
            if (left > right) return //循环递归的终止条件就是右边的指针大于右边的指针
            temp = arr[left] //设置一个基准值，都用最左边的元素
            var i = left //左指针
            var j = right //右指针
            while (i != j) { //判断是否基准值与数组中所有的数据进行了比较
                while (i < j && arr[j] >= temp) { //基准值与右边的元素比较，找出一个比自己小的，但左指针不能大于右指针
                    j-- //指针前移
                }
                while (i < j && arr[i] <= temp) { //基准值与自及左面的元素比较，找出一个比自己大的，但左指针不能大于右指针
                    i++ //指针后移
                }
                if (i < j) { //如果上面条件都跳出了，就判断时候指针相碰，如果没有相碰说明基准值并没有与所有数据进行比较，就无法确定基准值的位置
                    var c = arr[i] //那么我们就要修正一下数据保证基准值左边的是小的，右边是比他大的
                    arr[i] = arr[j]
                    arr[j] = c
                }
            } // 知道指针相碰处理完毕
            arr[left] = arr[i] //把指针待的位置与基准值交换位置，因为指针i确定的位置是基准值位置
            arr[i] = temp //把基准值放进i指针位置
            console.log(i, j)
            console.log(arr)
            quick(left, i - 1) //分别处理基准值左右边的数据，进行递归
            quick(i + 1, right)
        }
        //然后就会完成数据的排序
        quick(0, arr.length - 1)
    </script>
</body>
</html>
```

